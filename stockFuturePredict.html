<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Stock Predictor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Improved CSS styles */
    body {
      font-family: 'Roboto', sans-serif;
      background: #f8f9fa;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 1200px;
      background: #fff;
      margin: 0 auto;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .input-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .input-group {
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    label {
      display: block;
      margin-bottom: 8px;
      color: #2c3e50;
      font-weight: 500;
    }
    input, select {
      width: 100%;
      padding: 12px;
      border: 2px solid #dee2e6;
      border-radius: 6px;
      font-size: 14px;
    }
    button {
      background: #2c3e50;
      color: white;
      padding: 14px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    button:hover {
      background: #1a252f;
    }
    .chart-container {
      height: 500px;
      margin-top: 30px;
    }
    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 30px;
    }
    .metric-box {
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Advanced Stock Price Predictor</h1>
    
    <div class="input-section">
      <!-- Fundamental Analysis -->
      <div class="input-group">
        <label>Current Price ($)</label>
        <input type="number" id="price" step="0.01" required>
      </div>
      <div class="input-group">
        <label>EPS Growth Next 5Y (%)</label>
        <input type="number" id="epsGrowth" step="0.1" required>
      </div>
      <div class="input-group">
        <label>P/E Ratio</label>
        <input type="number" id="pe" step="0.1" required>
      </div>

      <!-- Technical Analysis -->
      <div class="input-group">
        <label>50-day MA ($)</label>
        <input type="number" id="ma50" step="0.01" required>
      </div>
      <div class="input-group">
        <label>200-day MA ($)</label>
        <input type="number" id="ma200" step="0.01" required>
      </div>
      <div class="input-group">
        <label>RSI (14-day)</label>
        <input type="number" id="rsi" min="0" max="100" required>
      </div>

      <!-- Market Factors -->
      <div class="input-group">
        <label>Risk-Free Rate (%)</label>
        <input type="number" id="riskFree" step="0.01" required>
      </div>
      <div class="input-group">
        <label>Beta (Volatility)</label>
        <input type="number" id="beta" step="0.1" required>
      </div>
      <div class="input-group">
        <label>Short Interest (%)</label>
        <input type="number" id="shortInterest" step="0.1" required>
      </div>
    </div>

    <button onclick="calculateAdvancedPrediction()">Generate Forecast</button>

    <div class="chart-container">
      <canvas id="priceChart"></canvas>
    </div>

    <div class="metrics" id="metrics"></div>

    <div class="disclaimer">
      <p><strong>Disclaimer:</strong> This tool employs advanced Monte Carlo simulations combining GARCH volatility, dynamic regime switching, and jump diffusion (using a Poisson process) with quantum-inspired variance reduction. Results are probabilistic forecasts, not guarantees. Past performance ≠ future results. Consult a financial advisor.</p>
    </div>
  </div>

  <script>
    /***************************************
     * Quantum-Inspired Variance Reduction *
     ***************************************/
    // A simplified low-discrepancy sequence generator (Sobol-like)
    function sobolSequence(dimensions, samples) {
      let seq = new Array(samples);
      for (let i = 0; i < samples; i++) {
        // Evenly spaced values in (0,1) (non-inclusive)
        seq[i] = new Array(dimensions).fill(0).map(() => (i + 1) / (samples + 1));
      }
      return seq;
    }

    // Convert the low-discrepancy sequence to normally distributed numbers using a Box–Muller-like method.
    function quantumInspiredRandom(samples) {
      let sobolSeq = sobolSequence(1, samples + 1);
      let results = [];
      for (let i = 0; i < samples; i++) {
        let u = sobolSeq[i][0];
        let u2 = sobolSeq[i+1][0];
        let z = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * u2);
        results.push(z);
      }
      return results;
    }

    // Importance sampling: adjust the shock by an importance weight.
    function importanceSampledShock(drift, sigma, importanceWeight, epsilon) {
      return drift + sigma * epsilon * importanceWeight;
    }

    // Helper function: standard tanh.
    function tanh(x) {
      return Math.tanh ? Math.tanh(x) : ((Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x)));
    }

    // Helper function: median.
    function median(arr) {
      let sorted = arr.slice().sort((a, b) => a - b);
      let mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
    }

    // Helper function: quantile.
    function quantileSeq(arr, quantile) {
      let sorted = arr.slice().sort((a, b) => a - b);
      let pos = (sorted.length - 1) * quantile;
      let base = Math.floor(pos);
      let rest = pos - base;
      return (sorted[base + 1] !== undefined)
              ? sorted[base] + rest * (sorted[base + 1] - sorted[base])
              : sorted[base];
    }

    // Poisson random generator (returns an integer)
    function poissonRandom(lambda) {
      let L = Math.exp(-lambda);
      let k = 0;
      let p = 1;
      do {
        k++;
        p *= Math.random();
      } while (p > L);
      return k - 1;
    }

    // Simple random normal generator (using Box-Muller)
    function randomNormal() {
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    let priceChart = null;

    function calculateAdvancedPrediction() {
      // Extract input values.
      const inputs = {
        price: parseFloat(document.getElementById('price').value),
        epsGrowth: parseFloat(document.getElementById('epsGrowth').value) / 100,
        pe: parseFloat(document.getElementById('pe').value),
        ma50: parseFloat(document.getElementById('ma50').value),
        ma200: parseFloat(document.getElementById('ma200').value),
        rsi: parseFloat(document.getElementById('rsi').value),
        riskFree: parseFloat(document.getElementById('riskFree').value) / 100,
        beta: parseFloat(document.getElementById('beta').value),
        shortInterest: parseFloat(document.getElementById('shortInterest').value) / 100
      };

      // 1. Fundamental Analysis (Discounted Cash Flow)
      const growthRate = inputs.epsGrowth;
      const discountRate = inputs.riskFree + inputs.beta * 0.055;
      if (discountRate <= growthRate) {
        alert("Invalid input: (risk-free + beta×0.055) must be greater than EPS Growth.");
        return;
      }
      const terminalValue = inputs.price * (1 + growthRate) / (discountRate - growthRate);
      const fundamentalScore = Math.log(terminalValue / inputs.price);

      // 2. Technical Analysis: Combine moving averages, RSI, and short interest effects.
      const maScore = ((inputs.price - inputs.ma50) / inputs.ma50) * 0.4 +
                      ((inputs.ma50 - inputs.ma200) / inputs.ma200) * 0.6;
      const rsiScore = tanh((inputs.rsi - 50) / 25) * 0.5;
      const shortInterestScore = -Math.log(1 + inputs.shortInterest * 10);
      const technicalScore = maScore + rsiScore + shortInterestScore;

      // 3. Simulation Setup
      const simulations = 2000;
      const timeSteps = 180; // 6 months of trading days.
      const sigma0 = inputs.beta * 0.2 / Math.sqrt(252);

      // --- GARCH parameters ---
      // (In practice, these would be calibrated using historical data.)
      const garchAlpha0 = 0.000001;
      const garchAlpha1 = 0.1;
      const garchBeta1 = 0.85;

      // --- Base Regime Switching parameters ---
      let baseRegimeProbability = 0.05;
      // Use a simple heuristic: if RSI is in extreme territory, increase probability.
      let dynamicRegimeProbability = baseRegimeProbability;
      if (inputs.rsi < 30 || inputs.rsi > 70) {
        dynamicRegimeProbability *= 2;
      }
      const turbulentFactor = 1.5;

      // --- Jump Diffusion parameters (using Poisson process) ---
      const jumpLambda = 0.03;   // Average number of jumps per day.
      const jumpMean = 0.02;     // Mean jump size.
      const jumpStd = 0.01;      // Std dev of jump size.

      let paths = [];
      for (let i = 0; i < simulations; i++) {
        let path = [inputs.price];
        let sigma = sigma0;
        let epsilons = quantumInspiredRandom(timeSteps);
        for (let j = 1; j < timeSteps; j++) {
          // Mean reversion factor: nudges price toward fundamental value.
          let reversionFactor = 0.00015 * (terminalValue - path[j - 1]) / inputs.price;
          
          // Dynamic regime switching: use dynamicRegimeProbability.
          let regimeFactor = (Math.random() < dynamicRegimeProbability) ? turbulentFactor : 1.0;
          
          // Jump diffusion: determine number of jumps today from Poisson distribution.
          let jumpCount = poissonRandom(jumpLambda);
          let totalJump = 0;
          for (let k = 0; k < jumpCount; k++) {
            // Each jump's direction is random; size sampled from normal distribution.
            totalJump += (Math.random() < 0.5 ? -1 : 1) * (jumpMean + jumpStd * randomNormal());
          }
          
          // Drift component: blend of growth, fundamental, technical, and mean reversion.
          let drift = (growthRate - 0.5 * sigma * sigma) / 252 +
                      fundamentalScore * 0.0003 +
                      technicalScore * 0.0003 +
                      reversionFactor;
          
          // Importance weight: reduced multiplier.
          let importanceWeight = 1 + Math.abs(drift) * 2;
          
          let epsilon = epsilons[j - 1];
          // Compute shock with importance sampling and add jump diffusion.
          let shock = importanceSampledShock(drift, sigma, importanceWeight, epsilon) * regimeFactor + totalJump;
          
          // Update price.
          let newPrice = path[j - 1] * Math.exp(shock);
          path.push(newPrice);
          
          // Revised GARCH update: here we use a simple update using the scaled epsilon.
          let epsilonScaled = sigma * epsilon;
          sigma = Math.sqrt(garchAlpha0 + garchAlpha1 * Math.pow(epsilonScaled, 2) + garchBeta1 * sigma * sigma);
        }
        paths.push(path);
      }

      // Compute simulation statistics.
      const finalPrices = paths.map(p => p[p.length - 1]);
      const medianPrice = median(finalPrices);
      const confLow = quantileSeq(finalPrices, 0.10);
      const confHigh = quantileSeq(finalPrices, 0.90);
      const upsideProbability = (finalPrices.filter(p => p > inputs.price).length / simulations) * 100;

      // Use numeric trading day labels.
      const labels = Array.from({ length: timeSteps }, (_, i) => i + 1);

      // Display metrics.
      document.getElementById('metrics').innerHTML = `
        <div class="metric-box">
          <h3>Median Forecast</h3>
          <p>$${medianPrice.toFixed(2)}</p>
        </div>
        <div class="metric-box">
          <h3>90% Confidence Range</h3>
          <p>$${confLow.toFixed(2)} - $${confHigh.toFixed(2)}</p>
        </div>
        <div class="metric-box">
          <h3>Upside Probability</h3>
          <p>${upsideProbability.toFixed(2)}%</p>
        </div>
      `;

      // Update the chart.
      if (priceChart) priceChart.destroy();
      const ctx = document.getElementById('priceChart').getContext('2d');
      priceChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Sample Simulation',
            data: paths[0],
            borderColor: 'rgba(44, 62, 80, 0.1)',
            pointRadius: 0,
            tension: 0.1
          }, {
            label: 'Median Forecast',
            data: paths[0].map((_, i) => median(paths.map(p => p[i]))),
            borderColor: '#2c3e50',
            borderWidth: 2,
            tension: 0.2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { title: { display: true, text: 'Price ($)' } },
            x: { title: { display: true, text: 'Trading Days' } }
          }
        }
      });
    }
  </script>
</body>
</html>

